<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TAuto K 线图</title>
    <style>
      :root {
        --bg: #0e1117;
        --panel: #161b22;
        --panel-border: #30363d;
        --text-primary: #e6edf3;
        --text-muted: #8b949e;
        --control-bg: #0d1117;
        --control-text: #e6edf3;
        --control-border: #30363d;
        --pane-border: #30363d;
        --tooltip-bg: rgba(13, 17, 23, 0.9);
        --tooltip-border: #f5d90a;
        --tooltip-text: #f5f5f5;
      }

      [data-theme="light"] {
        --bg: #f6f8fa;
        --panel: #ffffff;
        --panel-border: #d0d7de;
        --text-primary: #1f2328;
        --text-muted: #57606a;
        --control-bg: #ffffff;
        --control-text: #1f2328;
        --control-border: #d0d7de;
        --pane-border: #d0d7de;
        --tooltip-bg: rgba(255, 255, 255, 0.95);
        --tooltip-border: #f5d90a;
        --tooltip-text: #1f2328;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        background: var(--bg);
        color: var(--text-primary);
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 16px 24px;
        display: flex;
        align-items: center;
        gap: 16px;
        background: var(--panel);
        border-bottom: 1px solid var(--panel-border);
      }

      h1 {
        font-size: 18px;
        margin: 0;
        font-weight: 600;
      }

      .controls {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      select,
      input,
      button {
        background: var(--control-bg);
        color: var(--control-text);
        border: 1px solid var(--control-border);
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 14px;
      }

      button {
        cursor: pointer;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .control-group label {
        font-size: 13px;
        color: var(--text-muted);
      }

      .control-group input {
        width: 72px;
      }

      .content {
        padding: 16px 24px;
        display: flex;
        flex-direction: column;
        flex: 1;
        position: relative;
      }

      #chart {
        width: 100%;
        flex: 1;
        position: relative;
      }

      .meta {
        font-size: 13px;
        color: var(--text-muted);
        position: absolute;
        right: 24px;
        bottom: 12px;
      }

      .pane-border {
        border: 1px solid var(--pane-border);
        box-sizing: border-box;
      }

      .volume-tooltip {
        position: absolute;
        z-index: 20;
        background: var(--tooltip-bg);
        color: var(--tooltip-text);
        border: 1px solid var(--tooltip-border);
        border-radius: 6px;
        padding: 8px 10px;
        font-size: 12px;
        pointer-events: none;
        white-space: nowrap;
        opacity: 0;
        transform: translate(-50%, -100%);
        transition: opacity 0.15s ease;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>KLineChart 实时 K 线展示</h1>
      <div class="controls">
        <label for="barSelect">级别</label>
        <select id="barSelect">
          <option value="1m">1m</option>
          <option value="5m">5m</option>
          <option value="15m">15m</option>
          <option value="30m">30m</option>
          <option value="1h">1h</option>
        </select>
        <div class="control-group">
          <label for="windowInput">窗口W</label>
          <input id="windowInput" type="number" min="1" step="1" value="60" />
        </div>
        <div class="control-group">
          <label for="multiplierInput">倍数N</label>
          <input id="multiplierInput" type="number" min="1" step="0.1" value="5" />
        </div>
        <button id="themeToggle" type="button">明亮模式</button>
        <button id="refreshBtn" type="button">刷新</button>
      </div>
    </header>
    <main class="content">
      <div id="chart"></div>
      <div class="meta" id="meta"></div>
    </main>

    <script src="/static/vendor/klinecharts.min.js"></script>
    <script>
      const meta = document.getElementById("meta");
      const barSelect = document.getElementById("barSelect");
      const refreshBtn = document.getElementById("refreshBtn");
      const windowInput = document.getElementById("windowInput");
      const multiplierInput = document.getElementById("multiplierInput");
      const themeToggle = document.getElementById("themeToggle");
      const chartContainer = document.getElementById("chart");
      const chart = window.klinecharts ? klinecharts.init("chart") : null;
      const candlePaneId = "candle_pane";
      const volumePaneId = "volume_pane";
      const macdPaneId = "macd_pane";
      let currentTheme = "dark";
      if (!chart) {
        meta.textContent = "KLineChart 资源加载失败，请检查静态资源是否可访问。";
      } else {
        klinecharts.registerIndicator({
          name: "VOL_SPIKE",
          shortName: "VOL异常",
          series: klinecharts.IndicatorSeries.Volume,
          calcParams: [60, 5],
          figures: [
            {
              key: "spike",
              title: "异常: ",
              type: "circle",
            },
          ],
          styles: {
            circles: [
              {
                color: "#f5d90a",
                borderColor: "#fff7a8",
                borderSize: 2,
                size: 6,
              },
            ],
          },
          calc: (dataList, indicator) => {
            const windowSize = Math.max(1, Math.floor(indicator.calcParams[0]));
            const multiplier = Number(indicator.calcParams[1]);
            const buffer = [];
            let sum = 0;
            return dataList.map((item) => {
              const volume = Number(item.volume) || 0;
              buffer.push(volume);
              sum += volume;
              if (buffer.length > windowSize) {
                sum -= buffer.shift();
              }
              const mean = buffer.length ? sum / buffer.length : 0;
              const spike = mean > 0 && volume > mean * multiplier ? volume : null;
              return {
                spike,
                avgVolume: mean,
                currentVolume: volume,
                multiple: mean > 0 ? volume / mean : null,
              };
            });
          },
        });

        chart.createIndicator("MA", false, { id: candlePaneId });
        chart.createIndicator("VOL", false, { id: volumePaneId, height: 120 });
        chart.createIndicator("VOL_SPIKE", true, { id: volumePaneId });
        chart.createIndicator("MACD", false, { id: macdPaneId, height: 120 });
      }

      function getWindowSize() {
        const value = Math.floor(Number(windowInput.value));
        return Number.isFinite(value) && value > 0 ? value : 60;
      }

      function getMultiplier() {
        const value = Number(multiplierInput.value);
        return Number.isFinite(value) && value > 0 ? value : 5;
      }

      function updateVolumeSpikeIndicator() {
        if (!chart) {
          return;
        }
        chart.overrideIndicator(
          {
            name: "VOL_SPIKE",
            calcParams: [getWindowSize(), getMultiplier()],
          },
          volumePaneId,
        );
      }

      function applyPaneBorders() {
        if (!chart) {
          return;
        }
        [candlePaneId, volumePaneId, macdPaneId].forEach((paneId) => {
          const paneRoot = chart.getDom(paneId, klinecharts.DomPosition.Root);
          if (paneRoot) {
            paneRoot.classList.add("pane-border");
          }
        });
      }

      function updatePaneHeights() {
        if (!chart) {
          return;
        }
        const totalHeight = chartContainer.getBoundingClientRect().height;
        if (!totalHeight) {
          return;
        }
        const paneHeight = Math.max(60, Math.floor(totalHeight * 0.15));
        chart.setPaneOptions({ id: volumePaneId, height: paneHeight });
        chart.setPaneOptions({ id: macdPaneId, height: paneHeight });
        chart.resize();
      }

      function setTheme(theme) {
        currentTheme = theme;
        document.documentElement.dataset.theme = theme === "light" ? "light" : "dark";
        themeToggle.textContent = theme === "light" ? "暗黑模式" : "明亮模式";
      }

      function formatNumber(value) {
        if (!Number.isFinite(value)) {
          return "--";
        }
        return Number(value).toLocaleString(undefined, {
          maximumFractionDigits: 2,
        });
      }

      function createVolumeTooltip() {
        const tooltip = document.createElement("div");
        tooltip.className = "volume-tooltip";
        chartContainer.appendChild(tooltip);
        return tooltip;
      }

      const volumeTooltip = chart ? createVolumeTooltip() : null;

      function updateVolumeTooltip(payload) {
        if (!chart || !volumeTooltip) {
          return;
        }
        const dataIndex = payload?.dataIndex;
        if (dataIndex === null || dataIndex === undefined) {
          volumeTooltip.style.opacity = 0;
          return;
        }
        const dataList = chart.getDataList();
        const item = dataList[dataIndex];
        if (!item) {
          volumeTooltip.style.opacity = 0;
          return;
        }
        const windowSize = getWindowSize();
        const startIndex = Math.max(0, dataIndex - windowSize + 1);
        const windowSlice = dataList.slice(startIndex, dataIndex + 1);
        const sum = windowSlice.reduce((acc, row) => acc + (Number(row.volume) || 0), 0);
        const mean = windowSlice.length ? sum / windowSlice.length : 0;
        const volume = Number(item.volume) || 0;
        const multiple = mean > 0 ? volume / mean : null;
        const threshold = mean * getMultiplier();
        if (mean <= 0 || volume <= threshold) {
          volumeTooltip.style.opacity = 0;
          return;
        }
        volumeTooltip.innerHTML = [
          `均值VOL：${formatNumber(mean)}`,
          `当前VOL：${formatNumber(volume)}`,
          `倍数：${formatNumber(multiple)}`,
        ].join("<br />");
        const x = payload?.x ?? 0;
        const y = payload?.y ?? 0;
        volumeTooltip.style.left = `${x}px`;
        volumeTooltip.style.top = `${y}px`;
        volumeTooltip.style.opacity = 1;
      }

      async function loadCandles() {
        const bar = barSelect.value;
        refreshBtn.disabled = true;
        refreshBtn.textContent = "加载中...";
        if (!chart) {
          return;
        }
        try {
          const response = await fetch(`/api/candles?bar=${bar}`);
          if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
          }
          const payload = await response.json();
          const data = payload.data.map((item) => ({
            ...item,
            timestamp: Number(item.timestamp),
            open: Number(item.open),
            high: Number(item.high),
            low: Number(item.low),
            close: Number(item.close),
            volume: Number(item.volume),
          }));
          const sortedData = data.slice().sort((a, b) => a.timestamp - b.timestamp);
          chart.applyNewData(sortedData);
          updateVolumeSpikeIndicator();
          applyPaneBorders();
          updatePaneHeights();
          meta.textContent = `标的：${payload.instId} | 周期：${payload.bar} | 根数：${payload.count}`;
        } catch (error) {
          meta.textContent = `加载失败：${error.message}`;
        } finally {
          refreshBtn.disabled = false;
          refreshBtn.textContent = "刷新";
        }
      }

      barSelect.addEventListener("change", loadCandles);
      refreshBtn.addEventListener("click", loadCandles);
      windowInput.addEventListener("change", updateVolumeSpikeIndicator);
      multiplierInput.addEventListener("change", updateVolumeSpikeIndicator);
      themeToggle.addEventListener("click", () => {
        setTheme(currentTheme === "light" ? "dark" : "light");
      });
      if (chart) {
        chart.subscribeAction(klinecharts.ActionType.OnCrosshairChange, (payload) => {
          updateVolumeTooltip(payload);
        });
      }

      setTheme("dark");
      loadCandles();
      window.addEventListener("resize", updatePaneHeights);
      setInterval(loadCandles, 15000);
    </script>
  </body>
</html>
