<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>FreeBird</title>
    <style>
      :root {
        --bg: #0e1117;
        --panel: #161b22;
        --panel-border: #30363d;
        --text-primary: #e6edf3;
        --text-muted: #8b949e;
        --control-bg: #0d1117;
        --control-text: #e6edf3;
        --control-border: #30363d;
        --pane-border: #30363d;
        --tooltip-bg: rgba(13, 17, 23, 0.9);
        --tooltip-border: #f5d90a;
        --tooltip-text: #f5f5f5;
      }

      [data-theme="light"] {
        --bg: #f6f8fa;
        --panel: #ffffff;
        --panel-border: #d0d7de;
        --text-primary: #1f2328;
        --text-muted: #57606a;
        --control-bg: #ffffff;
        --control-text: #1f2328;
        --control-border: #d0d7de;
        --pane-border: #d0d7de;
        --tooltip-bg: rgba(255, 255, 255, 0.95);
        --tooltip-border: #f5d90a;
        --tooltip-text: #1f2328;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
        background: var(--bg);
        color: var(--text-primary);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      header {
        padding: 16px 24px;
        display: flex;
        align-items: center;
        gap: 16px;
        background: var(--panel);
        border-bottom: 1px solid var(--panel-border);
        flex-wrap: wrap;
      }

      h1 {
        font-size: 18px;
        margin: 0;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .bird-icon {
        width: 24px;
        height: 24px;
        color: var(--tooltip-border);
        flex-shrink: 0;
      }

      .controls {
        margin-left: auto;
        display: flex;
        align-items: flex-end;
        gap: 12px;
        flex-wrap: wrap;
        flex-direction: column;
      }

      select,
      input,
      button {
        background: var(--control-bg);
        color: var(--control-text);
        border: 1px solid var(--control-border);
        border-radius: 6px;
        padding: 6px 10px;
        font-size: 14px;
      }

      button {
        cursor: pointer;
      }

      .control-group {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .control-group label {
        font-size: 13px;
        color: var(--text-muted);
      }

      .control-group input {
        width: 72px;
      }

      .controls-row {
        display: flex;
        align-items: center;
        gap: 12px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .controls-row.secondary {
        gap: 8px;
      }

      .ma-toggles {
        display: flex;
        align-items: center;
        gap: 6px;
        flex-wrap: wrap;
      }

      .ma-label {
        font-size: 13px;
        color: var(--text-muted);
      }

      .ma-toggle-group {
        display: inline-flex;
        align-items: stretch;
        border: 1px solid var(--control-border);
        border-radius: 999px;
        overflow: visible;
        background: transparent;
      }

      .ma-toggle {
        background: transparent;
        border: none;
        color: var(--text-muted);
        padding: 4px 10px;
        font-size: 12px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .ma-toggle.active {
        color: var(--text-primary);
        border-color: var(--tooltip-border);
        box-shadow: 0 0 0 1px var(--tooltip-border);
      }

      .ma-color-dropdown {
        position: relative;
        display: inline-flex;
        align-items: stretch;
      }

      .ma-color-trigger {
        border: none;
        border-left: 1px solid var(--control-border);
        background: transparent;
        color: var(--text-muted);
        padding: 4px 8px;
        font-size: 12px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .ma-color-trigger::before {
        content: "";
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: var(--ma-color, #f97316);
        display: inline-block;
      }

      .ma-color-dropdown.open .ma-color-trigger {
        color: var(--text-primary);
      }

      .ma-color-menu {
        position: absolute;
        top: calc(100% + 6px);
        right: 0;
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 10px;
        min-width: 180px;
        display: none;
        flex-direction: column;
        gap: 8px;
        z-index: 20;
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
      }

      .ma-color-dropdown.open .ma-color-menu {
        display: flex;
      }

      .ma-color-row {
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .ma-color-row label {
        font-size: 12px;
        color: var(--text-muted);
        min-width: 36px;
      }

      .ma-color-row input {
        flex: 1;
        min-width: 0;
      }

      .ma-color-tip {
        font-size: 11px;
        color: var(--text-muted);
      }

      .content {
        padding: 16px 24px;
        display: flex;
        flex-direction: column;
        flex: 1;
        position: relative;
        min-height: 0;
      }

      .layout {
        display: flex;
        gap: 16px;
        flex: 1;
        min-height: 0;
      }

      .chart-area {
        flex: 1;
        min-width: 0;
        position: relative;
        display: flex;
      }

      #chart {
        width: 100%;
        flex: 1;
        position: relative;
        height: 100%;
      }

      .orderbook-panel {
        width: 260px;
        min-width: 220px;
        background: var(--panel);
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        display: flex;
        flex-direction: column;
        padding: 12px;
        gap: 8px;
      }

      .orderbook-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        font-size: 13px;
        color: var(--text-muted);
        gap: 8px;
      }

      .orderbook-title {
        font-weight: 600;
        color: var(--text-primary);
        white-space: nowrap;
      }

      #orderbookCanvas {
        width: 100%;
        flex: 1;
        border-radius: 6px;
        background: var(--control-bg);
      }

      .orderbook-tabs {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .orderbook-tab {
        border: 1px solid var(--control-border);
        background: transparent;
        color: var(--text-muted);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        cursor: pointer;
      }

      .orderbook-tab.active {
        color: var(--text-primary);
        border-color: var(--tooltip-border);
        box-shadow: 0 0 0 1px var(--tooltip-border);
      }

      .orderbook-body {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
        min-height: 0;
      }

      .orderbook-panel-content {
        display: none;
        flex: 1;
        min-height: 0;
        overflow: auto;
      }

      .orderbook-panel-content.active {
        display: flex;
        flex-direction: column;
      }

      .orderbook-spike-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 12px;
        color: var(--text-muted);
      }

      .orderbook-spike-controls label {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .orderbook-spike-controls input {
        width: 72px;
        padding: 4px 6px;
        font-size: 12px;
      }

      .orderbook-spike-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }

      .orderbook-spike-table th,
      .orderbook-spike-table td {
        padding: 4px 2px;
        border-bottom: 1px solid var(--panel-border);
        text-align: right;
        white-space: nowrap;
      }

      .orderbook-spike-table th {
        color: var(--text-muted);
        font-weight: 500;
      }

      .orderbook-spike-table th:first-child,
      .orderbook-spike-table td:first-child {
        text-align: left;
      }

      .orderbook-spike-empty {
        font-size: 12px;
        color: var(--text-muted);
        text-align: center;
        padding: 12px 0;
      }

      .meta {
        font-size: 13px;
        color: var(--text-muted);
        position: absolute;
        right: 16px;
        bottom: 12px;
      }

      .pane-border {
        border: 1px solid var(--pane-border);
        box-sizing: border-box;
      }

      .volume-tooltip {
        position: absolute;
        z-index: 20;
        background: var(--tooltip-bg);
        color: var(--tooltip-text);
        border: 1px solid var(--tooltip-border);
        border-radius: 6px;
        padding: 8px 10px;
        font-size: 12px;
        pointer-events: none;
        white-space: nowrap;
        opacity: 0;
        transform: translate(-50%, -100%);
        transition: opacity 0.15s ease;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>
        <svg
          class="bird-icon"
          viewBox="0 0 64 32"
          role="img"
          aria-label="飞翔的鸟"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path
            d="M6 22C14 10 28 8 36 14C41 8 50 6 58 10C49 11 43 15 39 20C32 15 22 16 14 22C11 24 8 24 6 22Z"
            fill="currentColor"
          />
          <path
            d="M33 15C35 12 39 10 44 10"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
          />
        </svg>
        show
      </h1>
      <div class="controls">
        <div class="controls-row">
          <label for="sourceSelect">数据源</label>
          <select id="sourceSelect">
            <option value="okx">OKX</option>
            <option value="binance">Binance</option>
          </select>
          <label for="barSelect">级别</label>
          <select id="barSelect"></select>
          <label for="instSelect">标的</label>
          <select id="instSelect"></select>
          <div class="control-group">
            <label for="windowInput">窗口W</label>
            <input id="windowInput" type="number" min="1" step="1" value="60" />
          </div>
          <div class="control-group">
            <label for="multiplierInput">倍数N</label>
            <input id="multiplierInput" type="number" min="1" step="0.1" value="5" />
          </div>
          <button id="themeToggle" type="button">明亮模式</button>
          <button id="colorToggle" type="button">涨跌色互换</button>
          <button id="refreshBtn" type="button">刷新</button>
        </div>
        <div class="controls-row secondary">
          <div class="ma-toggles" aria-label="均线显示">
            <span class="ma-label">均线</span>
            <div class="ma-toggle-group" data-ma-index="0">
              <button class="ma-toggle active" type="button" data-ma-index="0" aria-pressed="true">MA5</button>
              <div class="ma-color-dropdown" data-ma-index="0">
                <button class="ma-color-trigger" type="button" aria-label="MA5 颜色">▾</button>
                <div class="ma-color-menu" role="menu">
                  <div class="ma-color-row">
                    <label>预设</label>
                    <select class="ma-color-select" data-ma-index="0">
                      <option value="#f97316">橙色</option>
                      <option value="#06b6d4">青色</option>
                      <option value="#22c55e">绿色</option>
                      <option value="#eab308">黄色</option>
                      <option value="#3b82f6">蓝色</option>
                      <option value="#8b5cf6">紫色</option>
                      <option value="custom">自定义</option>
                    </select>
                  </div>
                  <div class="ma-color-row">
                    <label>RGB</label>
                    <input class="ma-color-input" data-ma-index="0" placeholder="255, 120, 20" />
                  </div>
                  <div class="ma-color-tip">可输入 RGB(255,0,0) 或 255,0,0</div>
                </div>
              </div>
            </div>
            <div class="ma-toggle-group" data-ma-index="1">
              <button class="ma-toggle active" type="button" data-ma-index="1" aria-pressed="true">MA10</button>
              <div class="ma-color-dropdown" data-ma-index="1">
                <button class="ma-color-trigger" type="button" aria-label="MA10 颜色">▾</button>
                <div class="ma-color-menu" role="menu">
                  <div class="ma-color-row">
                    <label>预设</label>
                    <select class="ma-color-select" data-ma-index="1">
                      <option value="#f97316">橙色</option>
                      <option value="#06b6d4">青色</option>
                      <option value="#22c55e">绿色</option>
                      <option value="#eab308">黄色</option>
                      <option value="#3b82f6">蓝色</option>
                      <option value="#8b5cf6">紫色</option>
                      <option value="custom">自定义</option>
                    </select>
                  </div>
                  <div class="ma-color-row">
                    <label>RGB</label>
                    <input class="ma-color-input" data-ma-index="1" placeholder="6, 182, 212" />
                  </div>
                  <div class="ma-color-tip">可输入 RGB(255,0,0) 或 255,0,0</div>
                </div>
              </div>
            </div>
            <div class="ma-toggle-group" data-ma-index="2">
              <button class="ma-toggle active" type="button" data-ma-index="2" aria-pressed="true">MA20</button>
              <div class="ma-color-dropdown" data-ma-index="2">
                <button class="ma-color-trigger" type="button" aria-label="MA20 颜色">▾</button>
                <div class="ma-color-menu" role="menu">
                  <div class="ma-color-row">
                    <label>预设</label>
                    <select class="ma-color-select" data-ma-index="2">
                      <option value="#f97316">橙色</option>
                      <option value="#06b6d4">青色</option>
                      <option value="#22c55e">绿色</option>
                      <option value="#eab308">黄色</option>
                      <option value="#3b82f6">蓝色</option>
                      <option value="#8b5cf6">紫色</option>
                      <option value="custom">自定义</option>
                    </select>
                  </div>
                  <div class="ma-color-row">
                    <label>RGB</label>
                    <input class="ma-color-input" data-ma-index="2" placeholder="34, 197, 94" />
                  </div>
                  <div class="ma-color-tip">可输入 RGB(255,0,0) 或 255,0,0</div>
                </div>
              </div>
            </div>
            <div class="ma-toggle-group" data-ma-index="3">
              <button class="ma-toggle active" type="button" data-ma-index="3" aria-pressed="true">MA60</button>
              <div class="ma-color-dropdown" data-ma-index="3">
                <button class="ma-color-trigger" type="button" aria-label="MA60 颜色">▾</button>
                <div class="ma-color-menu" role="menu">
                  <div class="ma-color-row">
                    <label>预设</label>
                    <select class="ma-color-select" data-ma-index="3">
                      <option value="#f97316">橙色</option>
                      <option value="#06b6d4">青色</option>
                      <option value="#22c55e">绿色</option>
                      <option value="#eab308">黄色</option>
                      <option value="#3b82f6">蓝色</option>
                      <option value="#8b5cf6">紫色</option>
                      <option value="custom">自定义</option>
                    </select>
                  </div>
                  <div class="ma-color-row">
                    <label>RGB</label>
                    <input class="ma-color-input" data-ma-index="3" placeholder="234, 179, 8" />
                  </div>
                  <div class="ma-color-tip">可输入 RGB(255,0,0) 或 255,0,0</div>
                </div>
              </div>
            </div>
            <div class="ma-toggle-group" data-ma-index="4">
              <button class="ma-toggle active" type="button" data-ma-index="4" aria-pressed="true">MA120</button>
              <div class="ma-color-dropdown" data-ma-index="4">
                <button class="ma-color-trigger" type="button" aria-label="MA120 颜色">▾</button>
                <div class="ma-color-menu" role="menu">
                  <div class="ma-color-row">
                    <label>预设</label>
                    <select class="ma-color-select" data-ma-index="4">
                      <option value="#f97316">橙色</option>
                      <option value="#06b6d4">青色</option>
                      <option value="#22c55e">绿色</option>
                      <option value="#eab308">黄色</option>
                      <option value="#3b82f6">蓝色</option>
                      <option value="#8b5cf6">紫色</option>
                      <option value="custom">自定义</option>
                    </select>
                  </div>
                  <div class="ma-color-row">
                    <label>RGB</label>
                    <input class="ma-color-input" data-ma-index="4" placeholder="59, 130, 246" />
                  </div>
                  <div class="ma-color-tip">可输入 RGB(255,0,0) 或 255,0,0</div>
                </div>
              </div>
            </div>
            <div class="ma-toggle-group" data-ma-index="5">
              <button class="ma-toggle active" type="button" data-ma-index="5" aria-pressed="true">MA250</button>
              <div class="ma-color-dropdown" data-ma-index="5">
                <button class="ma-color-trigger" type="button" aria-label="MA250 颜色">▾</button>
                <div class="ma-color-menu" role="menu">
                  <div class="ma-color-row">
                    <label>预设</label>
                    <select class="ma-color-select" data-ma-index="5">
                      <option value="#f97316">橙色</option>
                      <option value="#06b6d4">青色</option>
                      <option value="#22c55e">绿色</option>
                      <option value="#eab308">黄色</option>
                      <option value="#3b82f6">蓝色</option>
                      <option value="#8b5cf6">紫色</option>
                      <option value="custom">自定义</option>
                    </select>
                  </div>
                  <div class="ma-color-row">
                    <label>RGB</label>
                    <input class="ma-color-input" data-ma-index="5" placeholder="139, 92, 246" />
                  </div>
                  <div class="ma-color-tip">可输入 RGB(255,0,0) 或 255,0,0</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </header>
    <main class="content">
      <div class="layout">
        <div class="chart-area">
          <div id="chart"></div>
          <div class="meta" id="meta"></div>
        </div>
        <aside class="orderbook-panel">
          <div class="orderbook-header">
            <span class="orderbook-title">挂单量</span>
            <span id="orderbookStatus">--</span>
          </div>
          <div class="orderbook-body">
            <div class="orderbook-tabs" role="tablist" aria-label="挂单量视图">
              <button class="orderbook-tab active" type="button" data-tab="depth" role="tab" aria-selected="true">
                深度
              </button>
              <button class="orderbook-tab" type="button" data-tab="spike" role="tab" aria-selected="false">
                爆单/撤单
              </button>
            </div>
            <div class="orderbook-panel-content active" data-tab-panel="depth" role="tabpanel">
              <canvas id="orderbookCanvas"></canvas>
            </div>
            <div class="orderbook-panel-content" data-tab-panel="spike" role="tabpanel">
              <div class="orderbook-spike-controls">
                <label for="spikeWindowInput">参考时段t(s)</label>
                <input id="spikeWindowInput" type="number" min="1" step="1" value="30" />
                <label for="spikeThresholdInput">总阈值</label>
                <input id="spikeThresholdInput" type="number" min="0" step="1" value="50000" />
              </div>
              <div id="spikeTableContainer"></div>
            </div>
          </div>
        </aside>
      </div>
    </main>

    <script src="/static/vendor/klinecharts.min.js"></script>
    <script>
      const meta = document.getElementById("meta");
      const sourceSelect = document.getElementById("sourceSelect");
      const barSelect = document.getElementById("barSelect");
      const instSelect = document.getElementById("instSelect");
      const refreshBtn = document.getElementById("refreshBtn");
      const windowInput = document.getElementById("windowInput");
      const multiplierInput = document.getElementById("multiplierInput");
      const themeToggle = document.getElementById("themeToggle");
      const colorToggle = document.getElementById("colorToggle");
      const chartContainer = document.getElementById("chart");
      const orderbookCanvas = document.getElementById("orderbookCanvas");
      const orderbookStatus = document.getElementById("orderbookStatus");
      const orderbookTabButtons = document.querySelectorAll(".orderbook-tab");
      const orderbookTabPanels = document.querySelectorAll(".orderbook-panel-content");
      const spikeWindowInput = document.getElementById("spikeWindowInput");
      const spikeThresholdInput = document.getElementById("spikeThresholdInput");
      const spikeTableContainer = document.getElementById("spikeTableContainer");
      const chart = window.klinecharts ? klinecharts.init("chart") : null;
      const candlePaneId = "candle_pane";
      const volumePaneId = "volume_pane";
      const macdPaneId = "macd_pane";
      const maToggles = document.querySelectorAll(".ma-toggle");
      const maToggleGroups = document.querySelectorAll(".ma-toggle-group");
      const maColorDropdowns = document.querySelectorAll(".ma-color-dropdown");
      const maColorTriggers = document.querySelectorAll(".ma-color-trigger");
      const maColorSelects = document.querySelectorAll(".ma-color-select");
      const maColorInputs = document.querySelectorAll(".ma-color-input");
      const maColors = ["#f97316", "#06b6d4", "#22c55e", "#eab308", "#3b82f6", "#8b5cf6"];
      const maVisibility = Array.from({ length: maColors.length }, () => true);
      const volSpikeStyle = {
        color: "#f472b6",
        borderColor: "#fbcfe8",
        borderSize: 2,
        size: 8,
      };
      const volSpikeBlink = { on: true };
      const dataSources = {
        okx: {
          label: "OKX",
          bars: ["1m", "5m", "15m", "30m", "1h", "2h", "4h", "6h", "12h", "1d", "2d", "3d", "1w", "1M", "3M"],
          instruments: [
            { value: "BTC-USDT", label: "BTC-USDT" },
            { value: "BTC-USDT-SWAP", label: "BTC-USDT 永续" },
            { value: "ETH-USDT", label: "ETH-USDT" },
            { value: "ETH-USDT-SWAP", label: "ETH-USDT 永续" },
          ],
        },
        binance: {
          label: "Binance",
          bars: ["1m", "3m", "5m", "15m", "30m", "1h", "2h", "4h", "6h", "12h", "1d", "3d", "1w", "1M"],
          instruments: [
            { value: "BTCUSDT", label: "BTCUSDT" },
            { value: "ETHUSDT", label: "ETHUSDT" },
          ],
        },
      };
      let currentTheme = "dark";
      let useReversedColors = false;
      const volumeSpikeColor = "#a855f7";
      const getUpColor = () => (useReversedColors ? "#ef4444" : "#22c55e");
      const getDownColor = () => (useReversedColors ? "#22c55e" : "#ef4444");
      const getBaseVolumeColors = () => {
        const upColor = getUpColor();
        const downColor = getDownColor();
        return { upColor, downColor, noChangeColor: upColor };
      };
      let lastTimestamp = null;
      let priceRefreshRequestId = 0;
      let priceRefreshLatestAppliedId = 0;
      let orderBookRequestId = 0;
      let orderBookLatestAppliedId = 0;
      let lastOrderBook = null;
      let orderBookHistory = [];
      const orderBookContext = orderbookCanvas?.getContext("2d") ?? null;
      let historyLoadToken = 0;
      let historyLoadInFlight = false;
      const HISTORY_BATCH_SIZE = 500;
      const ORDERBOOK_HISTORY_LIMIT_MS = 10 * 60 * 1000;
      if (!chart) {
        meta.textContent = "KLineChart 资源加载失败，请检查静态资源是否可访问。";
      } else {
        chart.setStyles({
          grid: {
            horizontal: { show: true, color: "#d0d7de", size: 1, style: "solid" },
            vertical: { show: true, color: "#d0d7de", size: 1, style: "solid" },
          },
        });
        klinecharts.registerIndicator({
          name: "VOL_CUSTOM",
          shortName: "VOL",
          series: klinecharts.IndicatorSeries.Volume,
          calcParams: [60, 5],
          figures: [
            {
              key: "volume",
              title: "VOL: ",
              type: "bar",
              styles: ({ current }) => {
                const indicatorData = current?.indicatorData ?? {};
                const kLineData = current?.kLineData ?? {};
                if (indicatorData.isSpike) {
                  return { color: volumeSpikeColor };
                }
                const upColor = getUpColor();
                const downColor = getDownColor();
                return Number(kLineData.close) >= Number(kLineData.open) ? { color: upColor } : { color: downColor };
              },
            },
          ],
          styles: {
            bars: [getBaseVolumeColors()],
          },
          calc: (dataList, indicator) => {
            const windowSize = Math.max(1, Math.floor(indicator.calcParams[0]));
            const multiplier = Number(indicator.calcParams[1]);
            const volumes = dataList.map((item) => Number(item.volume) || 0);
            const prefixSum = [0];
            volumes.forEach((value, index) => {
              prefixSum[index + 1] = prefixSum[index] + value;
            });
            const latestStartIndex = Math.max(0, volumes.length - windowSize);
            const latestWindowSum = prefixSum[volumes.length] - prefixSum[latestStartIndex];
            const latestWindowLength = volumes.length - latestStartIndex;
            const latestMean = latestWindowLength > 0 ? latestWindowSum / latestWindowLength : 0;
            return volumes.map((volume, index) => {
              const startIndex = Math.max(0, index - windowSize + 1);
              const windowTotal = prefixSum[index + 1] - prefixSum[startIndex];
              const windowLength = index - startIndex + 1;
              const mean = windowLength > 0 ? windowTotal / windowLength : 0;
              const isSpike = latestMean > 0 && volume > latestMean * multiplier;
              return {
                volume,
                isSpike,
                avgVolume: mean,
              };
            });
          },
        });
        klinecharts.registerIndicator({
          name: "VOL_AVG_LINE",
          shortName: "VOL均值",
          series: klinecharts.IndicatorSeries.Volume,
          calcParams: [60],
          figures: [
            {
              key: "avgLine",
              title: "均值: ",
              type: "line",
            },
          ],
          styles: {
            lines: [
              {
                color: volumeSpikeColor,
                size: 1,
                style: "solid",
              },
            ],
          },
          calc: (dataList, indicator) => {
            const windowSize = Math.max(1, Math.floor(indicator.calcParams[0]));
            if (!dataList.length) {
              return [];
            }
            const startIndex = Math.max(0, dataList.length - windowSize);
            const slice = dataList.slice(startIndex);
            const sum = slice.reduce((acc, item) => acc + (Number(item.volume) || 0), 0);
            const mean = slice.length ? sum / slice.length : 0;
            return dataList.map(() => ({ avgLine: mean }));
          },
        });
        klinecharts.registerIndicator({
          name: "VOL_SPIKE",
          shortName: "VOL异常",
          series: klinecharts.IndicatorSeries.Volume,
          calcParams: [60, 5],
          figures: [
            {
              key: "spike",
              title: "异常: ",
              type: "circle",
            },
          ],
          styles: {
            circles: [
              {
                color: volSpikeStyle.color,
                borderColor: volSpikeStyle.borderColor,
                borderSize: volSpikeStyle.borderSize,
                size: volSpikeStyle.size,
              },
            ],
          },
          calc: (dataList, indicator) => {
            const windowSize = Math.max(1, Math.floor(indicator.calcParams[0]));
            const multiplier = Number(indicator.calcParams[1]);
            const buffer = [];
            let sum = 0;
            const volumes = dataList.map((item) => Number(item.volume) || 0);
            const latestStartIndex = Math.max(0, volumes.length - windowSize);
            const latestWindow = volumes.slice(latestStartIndex);
            const latestSum = latestWindow.reduce((acc, volume) => acc + volume, 0);
            const latestMean = latestWindow.length ? latestSum / latestWindow.length : 0;
            return dataList.map((item) => {
              const volume = Number(item.volume) || 0;
              buffer.push(volume);
              sum += volume;
              if (buffer.length > windowSize) {
                sum -= buffer.shift();
              }
              const mean = buffer.length ? sum / buffer.length : 0;
              const spike = latestMean > 0 && volume > latestMean * multiplier ? volume : null;
              return {
                spike,
                avgVolume: mean,
                currentVolume: volume,
                multiple: latestMean > 0 ? volume / latestMean : null,
              };
            });
          },
        });

        klinecharts.registerIndicator({
          name: "RT_PRICE",
          shortName: "实时价",
          series: klinecharts.IndicatorSeries.Price,
          figures: [
            {
              key: "price",
              title: "实时价: ",
              type: "line",
            },
          ],
          styles: {
            lines: [
              {
                color: "#3b82f6",
                size: 1,
                style: "solid",
              },
            ],
          },
          calc: (dataList) => {
            if (!dataList.length) {
              return [];
            }
            const lastClose = Number(dataList[dataList.length - 1].close);
            return dataList.map(() => ({ price: lastClose }));
          },
        });

        chart.createIndicator({ name: "MA", calcParams: [5, 10, 20, 60, 120, 250] }, false, {
          id: candlePaneId,
        });
        chart.createIndicator("VOL_CUSTOM", false, { id: volumePaneId, height: 120 });
        chart.createIndicator("VOL_AVG_LINE", true, { id: volumePaneId });
        chart.createIndicator("VOL_SPIKE", true, { id: volumePaneId });
        chart.createIndicator("MACD", false, { id: macdPaneId, height: 120 });
        chart.createIndicator("RT_PRICE", true, { id: candlePaneId });
      }

      function getWindowSize() {
        const value = Math.floor(Number(windowInput.value));
        return Number.isFinite(value) && value > 0 ? value : 60;
      }

      function getMultiplier() {
        const value = Number(multiplierInput.value);
        return Number.isFinite(value) && value > 0 ? value : 5;
      }

      function setCookie(name, value) {
        const expires = new Date();
        expires.setDate(expires.getDate() + 30);
        document.cookie = `${name}=${encodeURIComponent(value)}; expires=${expires.toUTCString()}; path=/`;
      }

      function getCookie(name) {
        const match = document.cookie.match(new RegExp(`(?:^|; )${name}=([^;]*)`));
        return match ? decodeURIComponent(match[1]) : null;
      }

      function updateVolumeIndicators() {
        if (!chart) {
          return;
        }
        chart.overrideIndicator(
          {
            name: "VOL_SPIKE",
            calcParams: [getWindowSize(), getMultiplier()],
          },
          volumePaneId,
        );
        chart.overrideIndicator(
          {
            name: "VOL_CUSTOM",
            calcParams: [getWindowSize(), getMultiplier()],
          },
          volumePaneId,
        );
        chart.overrideIndicator(
          {
            name: "VOL_AVG_LINE",
            calcParams: [getWindowSize()],
          },
          volumePaneId,
        );
      }

      function applyPaneBorders() {
        if (!chart) {
          return;
        }
        [candlePaneId, volumePaneId, macdPaneId].forEach((paneId) => {
          const paneRoot = chart.getDom(paneId, klinecharts.DomPosition.Root);
          if (paneRoot) {
            paneRoot.classList.add("pane-border");
          }
        });
      }

      function updatePaneHeights() {
        if (!chart) {
          return;
        }
        const totalHeight = chartContainer.getBoundingClientRect().height;
        if (!totalHeight) {
          return;
        }
        const candleHeight = Math.max(120, Math.floor(totalHeight * 0.6));
        const volumeHeight = Math.max(60, Math.floor(totalHeight * 0.15));
        const macdHeight = Math.max(60, Math.floor(totalHeight * 0.15));
        chart.setPaneOptions({ id: candlePaneId, height: candleHeight });
        chart.setPaneOptions({ id: volumePaneId, height: volumeHeight });
        chart.setPaneOptions({ id: macdPaneId, height: macdHeight });
        chart.resize();
      }

      function setTheme(theme) {
        currentTheme = theme;
        document.documentElement.dataset.theme = theme === "light" ? "light" : "dark";
        themeToggle.textContent = theme === "light" ? "暗黑模式" : "明亮模式";
        setCookie("tautoTheme", currentTheme);
        renderOrderBook(lastOrderBook);
        renderSpikeTable();
      }

      function applyCandleColors() {
        if (!chart) {
          return;
        }
        const upColor = getUpColor();
        const downColor = getDownColor();
        chart.setStyles({
          candle: {
            type: klinecharts.CandleType.CandleSolid,
            bar: {
              upColor,
              downColor,
              upBorderColor: upColor,
              downBorderColor: downColor,
              upWickColor: upColor,
              downWickColor: downColor,
            },
          },
        });
        chart.overrideIndicator(
          {
            name: "VOL_CUSTOM",
            styles: {
              bars: [
                {
                  upColor,
                  downColor,
                  noChangeColor: upColor,
                },
              ],
            },
          },
          volumePaneId,
        );
        chart.overrideIndicator(
          {
            name: "MACD",
            styles: {
              bars: [
                {
                  upColor,
                  downColor,
                  noChangeColor: upColor,
                },
              ],
            },
          },
          macdPaneId,
        );
        colorToggle.textContent = useReversedColors ? "恢复默认色" : "涨跌色互换";
        setCookie("tautoColorMode", useReversedColors ? "reversed" : "normal");
        renderOrderBook(lastOrderBook);
        renderSpikeTable();
      }

      function applyMALineStyles() {
        if (!chart) {
          return;
        }
        const lines = maColors.map((color, index) => {
          const visible = maVisibility[index];
          return {
            color: visible ? color : "transparent",
            size: visible ? 1 : 0,
            style: "solid",
          };
        });
        chart.overrideIndicator(
          {
            name: "MA",
            styles: { lines },
          },
          candlePaneId,
        );
      }

      function updateMAToggleGroupColor(index, color) {
        const group = Array.from(maToggleGroups).find((item) => Number(item.dataset.maIndex) === index);
        if (!group) {
          return;
        }
        group.style.setProperty("--ma-color", color);
      }

      function parseRgbInput(value) {
        const raw = String(value || "").trim();
        if (!raw) {
          return null;
        }
        const hexMatch = raw.match(/^#([0-9a-f]{6})$/i);
        if (hexMatch) {
          return raw;
        }
        const rgbMatch = raw.match(/^rgb\\s*\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/i);
        const shortMatch = raw.match(/^(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})$/);
        const match = rgbMatch || shortMatch;
        if (!match) {
          return null;
        }
        const values = match.slice(1, 4).map((item) => Number(item));
        if (values.some((num) => !Number.isFinite(num) || num < 0 || num > 255)) {
          return null;
        }
        return `rgb(${values.join(", ")})`;
      }

      function formatColorInput(color) {
        if (!color) {
          return "";
        }
        const rgbMatch = String(color).match(/^rgb\\((.*)\\)$/i);
        if (rgbMatch) {
          return rgbMatch[1];
        }
        return String(color);
      }

      function updateMAColor(index, color) {
        if (!Number.isFinite(index) || !color) {
          return;
        }
        maColors[index] = color;
        updateMAToggleGroupColor(index, color);
        applyMALineStyles();
      }

      function formatNumber(value) {
        if (!Number.isFinite(value)) {
          return "--";
        }
        return Number(value).toLocaleString(undefined, {
          maximumFractionDigits: 2,
        });
      }

      function formatCompactNumber(value) {
        if (!Number.isFinite(value)) {
          return "--";
        }
        return Number(value).toLocaleString(undefined, {
          maximumFractionDigits: 4,
        });
      }

      function getSpikeWindowSeconds() {
        const value = Math.floor(Number(spikeWindowInput?.value));
        return Number.isFinite(value) && value > 0 ? value : 30;
      }

      function getSpikeThreshold() {
        const value = Number(spikeThresholdInput?.value);
        return Number.isFinite(value) && value >= 0 ? value : 0;
      }

      function getOrderBookColors() {
        const bidColor = useReversedColors ? "#ef4444" : "#22c55e";
        const askColor = useReversedColors ? "#22c55e" : "#ef4444";
        return { bidColor, askColor };
      }

      function resizeOrderBookCanvas() {
        if (!orderbookCanvas || !orderBookContext) {
          return;
        }
        const rect = orderbookCanvas.getBoundingClientRect();
        if (!rect.width || !rect.height) {
          return;
        }
        const ratio = window.devicePixelRatio || 1;
        orderbookCanvas.width = Math.floor(rect.width * ratio);
        orderbookCanvas.height = Math.floor(rect.height * ratio);
        orderBookContext.setTransform(ratio, 0, 0, ratio, 0, 0);
        renderOrderBook(lastOrderBook);
      }

      function normalizeOrderBook(payload) {
        const bids = (payload?.bids ?? [])
          .map((row) => ({
            price: Number(row[0]),
            size: Number(row[1]),
          }))
          .filter((row) => Number.isFinite(row.price) && Number.isFinite(row.size));
        const asks = (payload?.asks ?? [])
          .map((row) => ({
            price: Number(row[0]),
            size: Number(row[1]),
          }))
          .filter((row) => Number.isFinite(row.price) && Number.isFinite(row.size));
        return {
          instId: payload?.instId ?? "",
          ts: Number(payload?.ts) || null,
          bids,
          asks,
        };
      }

      function pruneOrderBookHistory(referenceTs) {
        if (!referenceTs) {
          return;
        }
        const cutoff = referenceTs - ORDERBOOK_HISTORY_LIMIT_MS;
        orderBookHistory = orderBookHistory.filter((entry) => entry.ts && entry.ts >= cutoff);
      }

      function addOrderBookSnapshot(book) {
        if (!book || !book.ts) {
          return;
        }
        const lastEntry = orderBookHistory[orderBookHistory.length - 1];
        if (lastEntry && lastEntry.ts === book.ts) {
          orderBookHistory[orderBookHistory.length - 1] = book;
        } else {
          orderBookHistory.push(book);
        }
        pruneOrderBookHistory(book.ts);
      }

      function findReferenceSnapshot(targetTs) {
        for (let i = orderBookHistory.length - 1; i >= 0; i -= 1) {
          const entry = orderBookHistory[i];
          if (entry.ts && entry.ts <= targetTs) {
            return entry;
          }
        }
        return null;
      }

      function buildSizeMap(list) {
        const map = new Map();
        list.forEach((item) => {
          map.set(String(item.price), item.size);
        });
        return map;
      }

      function computeOrderBookSpikes(current, reference, threshold) {
        if (!current || !reference) {
          return [];
        }
        const rows = [];
        const sides = [
          { label: "买", data: current.bids, ref: reference.bids },
          { label: "卖", data: current.asks, ref: reference.asks },
        ];
        sides.forEach((side) => {
          const currentMap = buildSizeMap(side.data);
          const refMap = buildSizeMap(side.ref);
          const priceSet = new Set([...currentMap.keys(), ...refMap.keys()]);
          priceSet.forEach((priceKey) => {
            const price = Number(priceKey);
            if (!Number.isFinite(price)) {
              return;
            }
            const currentSize = currentMap.get(priceKey) ?? 0;
            const refSize = refMap.get(priceKey) ?? 0;
            const delta = currentSize - refSize;
            if (!delta) {
              return;
            }
            const notional = Math.abs(delta) * price;
            if (notional < threshold) {
              return;
            }
            rows.push({
              side: side.label,
              price,
              delta,
              notional,
            });
          });
        });
        return rows.sort((a, b) => b.notional - a.notional);
      }

      function renderSpikeTable() {
        if (!spikeTableContainer) {
          return;
        }
        if (!lastOrderBook) {
          spikeTableContainer.innerHTML = '<div class="orderbook-spike-empty">暂无挂单数据</div>';
          return;
        }
        const windowSeconds = getSpikeWindowSeconds();
        const targetTs = (lastOrderBook.ts ?? Date.now()) - windowSeconds * 1000;
        const reference = findReferenceSnapshot(targetTs);
        if (!reference) {
          spikeTableContainer.innerHTML = '<div class="orderbook-spike-empty">参考数据不足</div>';
          return;
        }
        const threshold = getSpikeThreshold();
        const rows = computeOrderBookSpikes(lastOrderBook, reference, threshold);
        if (!rows.length) {
          spikeTableContainer.innerHTML = '<div class="orderbook-spike-empty">暂无触发阈值的挂单变化</div>';
          return;
        }
        const { bidColor, askColor } = getOrderBookColors();
        const bodyHtml = rows
          .slice(0, 20)
          .map((row) => {
            const typeLabel = row.delta > 0 ? "爆单" : "撤单";
            const color = row.delta > 0 ? bidColor : askColor;
            return `
            <tr>
              <td style="color:${color}">${typeLabel}</td>
              <td>${row.side}</td>
              <td>${formatCompactNumber(row.price)}</td>
              <td>${formatCompactNumber(Math.abs(row.delta))}</td>
              <td>${formatCompactNumber(row.notional)}</td>
            </tr>
          `;
          })
          .join("");
        spikeTableContainer.innerHTML = `
          <table class="orderbook-spike-table">
            <thead>
              <tr>
                <th>类型</th>
                <th>方向</th>
                <th>价格</th>
                <th>数量变化</th>
                <th>变化值</th>
              </tr>
            </thead>
            <tbody>
              ${bodyHtml}
            </tbody>
          </table>
        `;
      }

      function renderOrderBook(book) {
        if (!orderBookContext || !orderbookCanvas) {
          return;
        }
        const width = orderbookCanvas.clientWidth;
        const height = orderbookCanvas.clientHeight;
        orderBookContext.clearRect(0, 0, width, height);
        orderBookContext.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--control-bg");
        orderBookContext.fillRect(0, 0, width, height);
        if (!book || (!book.bids.length && !book.asks.length)) {
          orderBookContext.fillStyle = getComputedStyle(document.documentElement).getPropertyValue(
            "--text-muted",
          );
          orderBookContext.font = "12px sans-serif";
          orderBookContext.textAlign = "center";
          orderBookContext.textBaseline = "middle";
          orderBookContext.fillText("暂无挂单数据", width / 2, height / 2);
          return;
        }
        const rowHeight = 18;
        const padding = 8;
        const availableHeight = Math.max(height - padding * 2, rowHeight);
        const rowsPerSide = Math.max(1, Math.floor(availableHeight / (rowHeight * 2)));
        const asks = book.asks.slice(0, rowsPerSide);
        const bids = book.bids.slice(0, rowsPerSide);
        const maxVolume = Math.max(
          1,
          ...asks.map((item) => item.size),
          ...bids.map((item) => item.size),
        );
        const { bidColor, askColor } = getOrderBookColors();
        const textColor = getComputedStyle(document.documentElement).getPropertyValue("--text-primary");
        const mutedColor = getComputedStyle(document.documentElement).getPropertyValue("--text-muted");
        const centerLineY = padding + rowsPerSide * rowHeight;
        orderBookContext.strokeStyle = mutedColor;
        orderBookContext.lineWidth = 1;
        orderBookContext.beginPath();
        orderBookContext.moveTo(padding, centerLineY);
        orderBookContext.lineTo(width - padding, centerLineY);
        orderBookContext.stroke();
        orderBookContext.font = "12px sans-serif";
        orderBookContext.textAlign = "left";
        orderBookContext.textBaseline = "middle";
        const barMaxWidth = width - padding * 2;

        asks.forEach((item, index) => {
          const y = padding + index * rowHeight + rowHeight / 2;
          const barWidth = (item.size / maxVolume) * barMaxWidth;
          orderBookContext.fillStyle = `${askColor}33`;
          orderBookContext.fillRect(width - padding - barWidth, y - rowHeight / 2 + 2, barWidth, rowHeight - 4);
          orderBookContext.fillStyle = askColor;
          orderBookContext.fillText(formatCompactNumber(item.price), padding, y);
          orderBookContext.textAlign = "right";
          orderBookContext.fillStyle = textColor;
          orderBookContext.fillText(formatCompactNumber(item.size), width - padding, y);
          orderBookContext.textAlign = "left";
        });

        bids.forEach((item, index) => {
          const y = centerLineY + index * rowHeight + rowHeight / 2;
          const barWidth = (item.size / maxVolume) * barMaxWidth;
          orderBookContext.fillStyle = `${bidColor}33`;
          orderBookContext.fillRect(width - padding - barWidth, y - rowHeight / 2 + 2, barWidth, rowHeight - 4);
          orderBookContext.fillStyle = bidColor;
          orderBookContext.fillText(formatCompactNumber(item.price), padding, y);
          orderBookContext.textAlign = "right";
          orderBookContext.fillStyle = textColor;
          orderBookContext.fillText(formatCompactNumber(item.size), width - padding, y);
          orderBookContext.textAlign = "left";
        });
      }

      function createVolumeTooltip() {
        const tooltip = document.createElement("div");
        tooltip.className = "volume-tooltip";
        chartContainer.appendChild(tooltip);
        return tooltip;
      }

      const volumeTooltip = chart ? createVolumeTooltip() : null;

      function updateVolumeTooltip(payload) {
        if (!chart || !volumeTooltip) {
          return;
        }
        const dataIndex = payload?.dataIndex;
        if (dataIndex === null || dataIndex === undefined) {
          volumeTooltip.style.opacity = 0;
          return;
        }
        const dataList = chart.getDataList();
        const item = dataList[dataIndex];
        if (!item) {
          volumeTooltip.style.opacity = 0;
          return;
        }
        const windowSize = getWindowSize();
        const latestStartIndex = Math.max(0, dataList.length - windowSize);
        const latestSlice = dataList.slice(latestStartIndex);
        const sum = latestSlice.reduce((acc, row) => acc + (Number(row.volume) || 0), 0);
        const mean = latestSlice.length ? sum / latestSlice.length : 0;
        const volume = Number(item.volume) || 0;
        const multiple = mean > 0 ? volume / mean : null;
        const threshold = mean * getMultiplier();
        if (mean <= 0 || volume <= threshold) {
          volumeTooltip.style.opacity = 0;
          return;
        }
        volumeTooltip.innerHTML = [
          `均值VOL：${formatNumber(mean)}`,
          `当前VOL：${formatNumber(volume)}`,
          `倍数：${formatNumber(multiple)}`,
        ].join("<br />");
        const x = payload?.x ?? 0;
        const y = payload?.y ?? 0;
        volumeTooltip.style.left = `${x}px`;
        volumeTooltip.style.top = `${y}px`;
        volumeTooltip.style.opacity = 1;
      }

      function normalizeCandles(list) {
        return list.map((item) => ({
          ...item,
          timestamp: Number(item.timestamp),
          open: Number(item.open),
          high: Number(item.high),
          low: Number(item.low),
          close: Number(item.close),
          volume: Number(item.volume),
        }));
      }

      function updateLastTimestamp(data) {
        if (data.length > 0) {
          lastTimestamp = data[data.length - 1].timestamp;
        }
      }

      function resetHistoryState() {
        lastTimestamp = null;
        priceRefreshRequestId = 0;
        priceRefreshLatestAppliedId = 0;
        historyLoadInFlight = false;
        historyLoadToken += 1;
        if (chart) {
          chart.applyNewData([]);
        }
      }

      function updateMeta(payload, extraNote = "") {
        const totalCount = chart ? chart.getDataList().length : 0;
        const note = extraNote ? ` | ${extraNote}` : "";
        const sourceLabel = dataSources[payload.source]?.label || payload.source || "OKX";
        meta.textContent = `数据源：${sourceLabel} | 标的：${payload.instId} | 周期：${payload.bar} | 根数：${totalCount}${note}`;
      }

      function setSelectOptions(select, options, currentValue) {
        select.innerHTML = "";
        options.forEach((option) => {
          const node = document.createElement("option");
          if (typeof option === "string") {
            node.value = option;
            node.textContent = option;
          } else {
            node.value = option.value;
            node.textContent = option.label;
          }
          select.appendChild(node);
        });
        if (currentValue && [...select.options].some((opt) => opt.value === currentValue)) {
          select.value = currentValue;
        } else if (select.options.length) {
          select.value = select.options[0].value;
        }
      }

      function applySourceOptions() {
        const source = sourceSelect.value;
        const config = dataSources[source] ?? dataSources.okx;
        setSelectOptions(barSelect, config.bars, barSelect.value);
        setSelectOptions(instSelect, config.instruments, instSelect.value);
      }

      async function loadRecentCandles() {
        const bar = barSelect.value;
        const instId = instSelect.value;
        const source = sourceSelect.value;
        if (historyLoadInFlight) {
          return;
        }
        refreshBtn.disabled = true;
        refreshBtn.textContent = "加载中...";
        if (!chart) {
          return;
        }
        try {
          if (!lastTimestamp) {
            await loadInitialCandles();
            return;
          }
          const params = new URLSearchParams({
            bar,
            inst_id: instId,
            source,
          });
          params.set("since_ts", String(lastTimestamp));
          const response = await fetch(`/api/candles?${params.toString()}`);
          if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
          }
          const payload = await response.json();
          const data = normalizeCandles(payload.data);
          const sortedData = data.slice().sort((a, b) => a.timestamp - b.timestamp);
          if (sortedData.length > 0) {
            sortedData.forEach((item) => {
              chart.updateData(item);
            });
          }
          updateLastTimestamp(sortedData);
          updateMeta(payload);
        } catch (error) {
          meta.textContent = `加载失败：${error.message}`;
        } finally {
          refreshBtn.disabled = false;
          refreshBtn.textContent = "刷新";
        }
      }

      async function loadInitialCandles() {
        const bar = barSelect.value;
        const instId = instSelect.value;
        const source = sourceSelect.value;
        const token = ++historyLoadToken;
        historyLoadInFlight = true;
        refreshBtn.disabled = true;
        refreshBtn.textContent = "加载中...";
        if (!chart) {
          return;
        }
        try {
          const params = new URLSearchParams({
            bar,
            inst_id: instId,
            limit: "300",
            source,
          });
          const response = await fetch(`/api/candles?${params.toString()}`);
          if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
          }
          const payload = await response.json();
          if (token !== historyLoadToken) {
            return;
          }
          const data = normalizeCandles(payload.data);
          const sortedData = data.slice().sort((a, b) => a.timestamp - b.timestamp);
          chart.applyNewData(sortedData);
          updateVolumeIndicators();
          applyPaneBorders();
          updatePaneHeights();
          updateLastTimestamp(sortedData);
          updateMeta(payload, "补全中");
        } catch (error) {
          meta.textContent = `加载失败：${error.message}`;
        } finally {
          if (token === historyLoadToken) {
            historyLoadInFlight = false;
            refreshBtn.disabled = false;
            refreshBtn.textContent = "刷新";
          }
        }
      }

      async function loadMoreHistory(timestampHint) {
        if (!chart || historyLoadInFlight) {
          return;
        }
        const dataList = chart.getDataList();
        if (!dataList.length) {
          return;
        }
        const bar = barSelect.value;
        const instId = instSelect.value;
        const source = sourceSelect.value;
        const earliestTs = Number(timestampHint || dataList[0].timestamp);
        if (!Number.isFinite(earliestTs)) {
          return;
        }
        historyLoadInFlight = true;
        try {
          const params = new URLSearchParams({
            bar,
            inst_id: instId,
            limit: String(HISTORY_BATCH_SIZE),
            source,
          });
          params.set("end_ts", String(earliestTs - 1));
          const response = await fetch(`/api/candles?${params.toString()}`);
          if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
          }
          const payload = await response.json();
          const data = normalizeCandles(payload.data);
          const sortedData = data.slice().sort((a, b) => a.timestamp - b.timestamp);
          if (sortedData.length === 0) {
            updateMeta(payload);
            return;
          }
          chart.applyMoreData(sortedData);
          updateMeta(payload, "补全中");
        } catch (error) {
          meta.textContent = `补全失败：${error.message}`;
        } finally {
          historyLoadInFlight = false;
        }
      }

      async function refreshRealtimePrice() {
        if (!chart) {
          return;
        }
        const requestId = ++priceRefreshRequestId;
        try {
          const params = new URLSearchParams({
            inst_id: instSelect.value,
            source: sourceSelect.value,
          });
          const response = await fetch(`/api/ticker?${params.toString()}`);
          if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
          }
          const payload = await response.json();
          if (payload.instId !== instSelect.value) {
            return;
          }
          const lastPrice = Number(payload.last);
          if (!Number.isFinite(lastPrice)) {
            return;
          }
          if (requestId < priceRefreshLatestAppliedId) {
            return;
          }
          priceRefreshLatestAppliedId = requestId;
          const dataList = chart.getDataList();
          if (!dataList.length) {
            return;
          }
          const lastCandle = dataList[dataList.length - 1];
          const updatedCandle = {
            ...lastCandle,
            close: lastPrice,
            high: Math.max(Number(lastCandle.high) || lastPrice, lastPrice),
            low: Math.min(Number(lastCandle.low) || lastPrice, lastPrice),
          };
          chart.updateData(updatedCandle);
        } catch (error) {
          console.warn("实时价格更新失败", error);
        }
      }

      async function loadOrderBook() {
        if (!orderbookStatus) {
          return;
        }
        const requestId = ++orderBookRequestId;
        try {
          const params = new URLSearchParams({
            inst_id: instSelect.value,
            depth: "20",
            source: sourceSelect.value,
          });
          const response = await fetch(`/api/orderbook?${params.toString()}`);
          if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
          }
          const payload = await response.json();
          if (payload.instId !== instSelect.value) {
            return;
          }
          if (requestId < orderBookLatestAppliedId) {
            return;
          }
          orderBookLatestAppliedId = requestId;
          lastOrderBook = normalizeOrderBook(payload);
          addOrderBookSnapshot(lastOrderBook);
          renderOrderBook(lastOrderBook);
          renderSpikeTable();
          const ts = lastOrderBook.ts ? new Date(lastOrderBook.ts).toLocaleTimeString() : "--";
          orderbookStatus.textContent = `更新 ${ts}`;
        } catch (error) {
          orderbookStatus.textContent = "挂单获取失败";
        }
      }

      orderbookTabButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const tab = button.dataset.tab;
          if (!tab) {
            return;
          }
          orderbookTabButtons.forEach((btn) => {
            const isActive = btn.dataset.tab === tab;
            btn.classList.toggle("active", isActive);
            btn.setAttribute("aria-selected", isActive ? "true" : "false");
          });
          orderbookTabPanels.forEach((panel) => {
            panel.classList.toggle("active", panel.dataset.tabPanel === tab);
          });
          if (tab === "spike") {
            renderSpikeTable();
          } else {
            resizeOrderBookCanvas();
          }
        });
      });

      barSelect.addEventListener("change", () => {
        resetHistoryState();
        loadInitialCandles();
      });
      barSelect.addEventListener("change", () => {
        setCookie("tautoBar", barSelect.value);
      });
      instSelect.addEventListener("change", () => {
        setCookie("tautoInst", instSelect.value);
      });
      instSelect.addEventListener("change", () => {
        resetHistoryState();
        orderBookHistory = [];
        loadInitialCandles();
        loadOrderBook();
      });
      sourceSelect.addEventListener("change", () => {
        setCookie("tautoSource", sourceSelect.value);
        applySourceOptions();
        resetHistoryState();
        orderBookHistory = [];
        loadInitialCandles();
        loadOrderBook();
      });
      refreshBtn.addEventListener("click", loadRecentCandles);
      windowInput.addEventListener("change", updateVolumeIndicators);
      windowInput.addEventListener("change", () => {
        setCookie("tautoWindow", windowInput.value);
      });
      multiplierInput.addEventListener("change", updateVolumeIndicators);
      multiplierInput.addEventListener("change", () => {
        setCookie("tautoMultiplier", multiplierInput.value);
      });
      spikeWindowInput?.addEventListener("change", renderSpikeTable);
      spikeThresholdInput?.addEventListener("change", renderSpikeTable);
      themeToggle.addEventListener("click", () => {
        setTheme(currentTheme === "light" ? "dark" : "light");
      });
      colorToggle.addEventListener("click", () => {
        useReversedColors = !useReversedColors;
        applyCandleColors();
      });
      function closeAllColorMenus(exceptIndex = null) {
        maColorDropdowns.forEach((dropdown) => {
          const index = Number(dropdown.dataset.maIndex);
          if (Number.isFinite(exceptIndex) && index === exceptIndex) {
            return;
          }
          dropdown.classList.remove("open");
        });
      }
      maToggleGroups.forEach((group) => {
        const index = Number(group.dataset.maIndex);
        if (!Number.isFinite(index)) {
          return;
        }
        updateMAToggleGroupColor(index, maColors[index]);
      });
      maColorTriggers.forEach((trigger) => {
        trigger.addEventListener("click", (event) => {
          event.stopPropagation();
          const index = Number(trigger.closest(".ma-color-dropdown")?.dataset.maIndex);
          if (!Number.isFinite(index)) {
            return;
          }
          const dropdown = Array.from(maColorDropdowns).find((item) => Number(item.dataset.maIndex) === index);
          if (!dropdown) {
            return;
          }
          const isOpen = dropdown.classList.contains("open");
          closeAllColorMenus(isOpen ? null : index);
          dropdown.classList.toggle("open", !isOpen);
        });
      });
      maColorSelects.forEach((select) => {
        const index = Number(select.dataset.maIndex);
        if (!Number.isFinite(index)) {
          return;
        }
        const presetValues = Array.from(select.options)
          .map((option) => option.value)
          .filter((value) => value !== "custom");
        if (presetValues.includes(maColors[index])) {
          select.value = maColors[index];
        } else {
          select.value = "custom";
        }
        select.addEventListener("change", () => {
          if (select.value === "custom") {
            return;
          }
          updateMAColor(index, select.value);
          const input = Array.from(maColorInputs).find((item) => Number(item.dataset.maIndex) === index);
          if (input) {
            input.value = formatColorInput(select.value);
          }
        });
      });
      maColorInputs.forEach((input) => {
        const index = Number(input.dataset.maIndex);
        if (!Number.isFinite(index)) {
          return;
        }
        input.value = formatColorInput(maColors[index]);
        input.addEventListener("change", () => {
          const color = parseRgbInput(input.value);
          if (!color) {
            return;
          }
          updateMAColor(index, color);
          const select = Array.from(maColorSelects).find((item) => Number(item.dataset.maIndex) === index);
          if (select) {
            const presetMatch = Array.from(select.options).some((option) => option.value === color);
            select.value = presetMatch ? color : "custom";
          }
        });
      });
      document.addEventListener("click", (event) => {
        if (!(event.target instanceof HTMLElement)) {
          return;
        }
        if (event.target.closest(".ma-color-dropdown")) {
          return;
        }
        closeAllColorMenus();
      });
      maToggles.forEach((toggle) => {
        toggle.addEventListener("click", () => {
          const index = Number(toggle.dataset.maIndex);
          if (!Number.isFinite(index)) {
            return;
          }
          maVisibility[index] = !maVisibility[index];
          toggle.classList.toggle("active", maVisibility[index]);
          toggle.setAttribute("aria-pressed", maVisibility[index] ? "true" : "false");
          applyMALineStyles();
        });
      });
      if (chart) {
        chart.subscribeAction(klinecharts.ActionType.OnCrosshairChange, (payload) => {
          updateVolumeTooltip(payload);
        });
        chart.loadMore((timestamp) => {
          loadMoreHistory(timestamp);
        });
      }

      setInterval(() => {
        if (!chart) {
          return;
        }
        volSpikeBlink.on = !volSpikeBlink.on;
        const color = volSpikeBlink.on ? volSpikeStyle.color : "transparent";
        const borderColor = volSpikeBlink.on ? volSpikeStyle.borderColor : "transparent";
        chart.overrideIndicator(
          {
            name: "VOL_SPIKE",
            styles: {
              circles: [
                {
                  color,
                  borderColor,
                  borderSize: volSpikeStyle.borderSize,
                  size: volSpikeStyle.size,
                },
              ],
            },
          },
          volumePaneId,
        );
      }, 700);

      const savedBar = getCookie("tautoBar");
      const savedSource = getCookie("tautoSource");
      if (savedSource && [...sourceSelect.options].some((option) => option.value === savedSource)) {
        sourceSelect.value = savedSource;
      }
      applySourceOptions();
      if (savedBar && [...barSelect.options].some((option) => option.value === savedBar)) {
        barSelect.value = savedBar;
      }
      const savedInst = getCookie("tautoInst");
      if (savedInst && [...instSelect.options].some((option) => option.value === savedInst)) {
        instSelect.value = savedInst;
      }
      const savedWindow = getCookie("tautoWindow");
      if (savedWindow) {
        windowInput.value = savedWindow;
      }
      const savedMultiplier = getCookie("tautoMultiplier");
      if (savedMultiplier) {
        multiplierInput.value = savedMultiplier;
      }
      const savedTheme = getCookie("tautoTheme") || "dark";
      setTheme(savedTheme);
      const savedColorMode = getCookie("tautoColorMode");
      useReversedColors = savedColorMode === "reversed";
      applyCandleColors();
      applyMALineStyles();
      loadInitialCandles();
      resizeOrderBookCanvas();
      loadOrderBook();
      window.addEventListener("resize", updatePaneHeights);
      window.addEventListener("resize", resizeOrderBookCanvas);
      setInterval(loadRecentCandles, 15000);
      setInterval(refreshRealtimePrice, 100);
      setInterval(loadOrderBook, 1000);
    </script>
  </body>
</html>
